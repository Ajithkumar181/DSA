Got it ğŸ‘ Letâ€™s make **quick revision notes** for this code (`deleteAndEarn` problem from LeetCode).

---

## ğŸ”‘ Quick Revision Notes â€“ `deleteAndEarn`

### Problem Idea

* Similar to **House Robber problem**.
* If you take a number `x`, you **earn points = x \* frequency(x)**.
* But then you must delete **all occurrences of (x-1) and (x+1)**.
* Goal: maximize points earned.

---

### Steps in Code

1. **Find max element**

   ```cpp
   int maxi = *max_element(nums.begin(), nums.end());
   ```

   â†’ Needed to size the DP array properly.

2. **Build cost array**

   ```cpp
   vector<int> cost(maxi+1, 0);
   for (int it : nums) {
       cost[it] += it;
   }
   ```

   * `cost[i] = i * frequency(i)`
   * Reduces problem into **linear DP**.

3. **Recursive + Memoization DP**

   ```cpp
   int solve(int idx, int n, vector<int>& nums, vector<int>& dp) {
       if (idx >= n) return 0;
       if (dp[idx] != -1) return dp[idx];

       int taken = nums[idx] + solve(idx + 2, n, nums, dp);
       int notTaken = solve(idx + 1, n, nums, dp);

       return dp[idx] = max(taken, notTaken);
   }
   ```

   * **Choices**:

     * Take current â†’ skip next (`idx+2`)
     * Skip current â†’ move to (`idx+1`)

   â†’ Same as **House Robber**.

4. **Final Answer**

   ```cpp
   return max(solve(0, n+1, cost, dp), solve(1, n+1, cost, dp));
   ```

   * Start from index 0 or 1 (whichever gives max).

---

### Complexity

* **Time:** `O(max(nums))` (linear DP)
* **Space:** `O(max(nums))` (for `dp` and `cost`)

---

### Key Takeaways

* Convert problem into **House Robber** by mapping nums â†’ `cost[i]`.
* Always think:

  * Take â†’ skip next
  * Skip â†’ move next
* Works better than sorting since indices are **values themselves**.

---

ğŸ‘‰ Do you want me to also make a **visual workflow diagram (like a revision map)** for this, so you can quickly revise before exams/interviews?
