Got it 👍 Let’s make **quick revision notes** for this problem (your code is for **House Robber II – Circular Houses**).

---

# 📝 Revision Notes – House Robber II (Circular)

---

## 🔹 Problem Statement

* You are a robber.
* Each house has some money.
* Cannot rob two adjacent houses.
* **Circular constraint**: First and last houses are adjacent.
* Goal: **Maximize total money robbed**.

---

## 🔹 Key Idea

* If houses were in a **line** (House Robber I), just pick non-adjacent houses → classic DP.
* But here houses are **circular**:

  * If you rob the **first house**, you **cannot rob the last house**.
  * If you rob the **last house**, you **cannot rob the first house**.
* So, split into **two cases**:

  1. Rob from **house 0 → n-2** (exclude last house).
  2. Rob from **house 1 → n-1** (exclude first house).
* Answer = **max(case1, case2)**.

---

## 🔹 Recursive + Memoization Approach

### Function: `solve(idx, n, nums, dp)`

* **Base case**: If `idx >= n`, return `0`.
* **Check memo**: If already computed, return `dp[idx]`.
* **Choices**:

  * **Take**: `nums[idx] + solve(idx+2, n, nums, dp)`
  * **Skip**: `solve(idx+1, n, nums, dp)`
* Store and return: `dp[idx] = max(take, skip)`.

---

## 🔹 Main Function: `rob(nums)`

1. Edge case: If only one house → return `nums[0]`.
2. Compute:

   * `case1 = solve(0, n-1, nums, dp1)` → exclude last house.
   * `case2 = solve(1, n, nums, dp2)` → exclude first house.
3. Return `max(case1, case2)`.

---

## 🔹 Time & Space Complexity

* **Time**: `O(n)` (each index computed once).
* **Space**:

  * `O(n)` for recursion stack + DP array (top-down).
  * Can be reduced to `O(1)` using bottom-up with 2 variables.

---

## 🔹 Example Walkthrough

Input: `nums = [2, 3, 2]`

* Case 1 (exclude last): Rob `[2, 3]` → max = 3
* Case 2 (exclude first): Rob `[3, 2]` → max = 3
* Final answer = 3.

---

⚡ **Tip for exams/placements**:

* **House Robber I (linear)** → single `solve(0, n, nums, dp)`.
* **House Robber II (circular)** → two solves, exclude first OR last.

---

Do you also want me to write the **space-optimized bottom-up version** (no DP array, just two variables) for quick recall?
class Solution {
public:
    int solve(int idx, int n, vector<int>& nums, vector<int>& dp) {
        if (idx >= n) return 0;
        if (dp[idx] != -1) return dp[idx];

        int taken = nums[idx] + solve(idx + 2, n, nums, dp);
        int notTaken = solve(idx + 1, n, nums, dp);

        return dp[idx] = max(taken, notTaken);
    }

    int rob(vector<int>& nums) {
        if (nums.size() == 1) return nums[0]; // only one house

        int n = nums.size();
        vector<int> dp1(n, -1), dp2(n, -1);

        // Case 1: Exclude last house
        int case1 = solve(0, n - 1, nums, dp1);

        // Case 2: Exclude first house
        int case2 = solve(1, n, nums, dp2);

        return max(case1, case2);
    }
};
