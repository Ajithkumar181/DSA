Got it üëç I‚Äôll add the **problem statement** at the very start and keep everything else as you structured.

---

# ‚ùì Problem Statement

The **Tribonacci sequence** is defined as follows:

* `T0 = 0`, `T1 = 1`, `T2 = 1`
* For `n ‚â• 3`:

  ```
  Tn = T(n-1) + T(n-2) + T(n-3)
  ```

Given an integer `n`, return the value of `Tn`.

---

## üöÄ Approach

* **Tribonacci definition:**

  ```
  T0 = 0, T1 = 1, T2 = 1
  Tn = T(n-1) + T(n-2) + T(n-3)  for n ‚â• 3
  ```

* We can solve it with:

  1. **Recursion + Memoization (Top-Down DP)**
  2. **Tabulation (Bottom-Up DP)** ‚Üí more efficient, no recursion overhead

---

## ‚úÖ Code (Top-Down: Recursion + Memoization)

```cpp
class Solution {
public:
    int solve(int n, vector<int>& dp) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) return 1;

        if (dp[n] != -1) return dp[n];

        return dp[n] = solve(n-1, dp) + solve(n-2, dp) + solve(n-3, dp);
    }

    int tribonacci(int n) {
        vector<int> dp(n+1, -1);
        return solve(n, dp);
    }
};
```

---

## ‚úÖ Code (Bottom-Up: Iterative DP ‚Üí Optimized)

```cpp
class Solution {
public:
    int tribonacci(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) return 1;

        int t0 = 0, t1 = 1, t2 = 1, t3;
        for (int i = 3; i <= n; i++) {
            t3 = t0 + t1 + t2;
            t0 = t1;
            t1 = t2;
            t2 = t3;
        }
        return t2;
    }
};
```

üëâ This uses **only 3 variables**, instead of a whole `dp` array.

---

## üìù Dry Run (Example: n = 4)

**Tribonacci sequence:**

```
T0 = 0, T1 = 1, T2 = 1
T3 = T2 + T1 + T0 = 1 + 1 + 0 = 2
T4 = T3 + T2 + T1 = 2 + 1 + 1 = 4
```

So, **Output = 4**

**Iterative Trace:**

```
t0=0, t1=1, t2=1
i=3 ‚Üí t3 = 0+1+1=2 ‚Üí shift ‚Üí t0=1, t1=1, t2=2
i=4 ‚Üí t3 = 1+1+2=4 ‚Üí shift ‚Üí t0=1, t1=2, t2=4
Answer = 4
```

---

## üìä Time & Space Complexity

### Top-Down (Recursion + Memoization)

* **Time Complexity:** O(n) (each state solved once)
* **Space Complexity:** O(n) for `dp` + O(n) recursion stack

### Bottom-Up (Optimized)

* **Time Complexity:** O(n)
* **Space Complexity:** O(1) (only 3 variables)

---

‚úÖ **Final Note:** In interviews, start with recursion + memoization for clarity, then optimize to **O(1) space** bottom-up solution.

---

üëâ Do you want me to now add a **comparison table (Recursion vs Bottom-Up)** for a super quick one-glance revision before exams/interviews?
