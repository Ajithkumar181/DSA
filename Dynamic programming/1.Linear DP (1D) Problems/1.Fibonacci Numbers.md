Nice pick Ajith! üî• Let‚Äôs make **revision notes** for your Fibonacci DP code step by step with **dry run, space & time complexity, and explanation**.

---

# üìò Problem: Fibonacci Number (LeetCode 509)

We need to return the **n-th Fibonacci number**:

* `F(0) = 0`
* `F(1) = 1`
* `F(n) = F(n-1) + F(n-2)`

---

## ‚ú® Code (Top-Down DP / Memoization)

```cpp
class Solution {
public:
    int solve(int n, vector<int>& dp) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        if (dp[n] != -1) return dp[n];   // already computed
        return dp[n] = solve(n-1, dp) + solve(n-2, dp);
    }

    int fib(int n) {
        vector<int> dp(n+1, -1);  // memoization table
        return solve(n, dp);
    }
};
```

---

## üîé Dry Run (Example: `n = 5`)

Call ‚Üí `fib(5)`

* `dp = [-1,-1,-1,-1,-1,-1]`

### Step 1

`solve(5)` ‚Üí needs `solve(4)` + `solve(3)`

### Step 2

`solve(4)` ‚Üí needs `solve(3)` + `solve(2)`

### Step 3

`solve(3)` ‚Üí needs `solve(2)` + `solve(1)`

### Step 4

`solve(2)` ‚Üí needs `solve(1)` + `solve(0)`

* `solve(1)=1`
* `solve(0)=0`
* So `solve(2)=1` ‚Üí store in `dp[2]=1`

### Step 5

Now `solve(3)` = `dp[2] + solve(1)` = `1 + 1 = 2` ‚Üí store in `dp[3]=2`

### Step 6

Now `solve(4)` = `dp[3] + dp[2]` = `2 + 1 = 3` ‚Üí store in `dp[4]=3`

### Step 7

Now `solve(5)` = `dp[4] + dp[3]` = `3 + 2 = 5` ‚Üí store in `dp[5]=5`

‚úÖ Answer = `5`

---

## ‚è± Time Complexity (TC)

* Without DP: **Exponential** `O(2^n)` (too many repeated calls).
* With Memoization: Each state (`n`) is solved once ‚Üí **O(n)**.

---

## üíæ Space Complexity (SC)

* `dp` array: **O(n)**
* Recursion stack: **O(n)** (worst-case depth)
* Total: **O(n)**

---

## ‚úÖ Key Notes

1. This is **Top-Down DP (Recursion + Memoization)**.
2. Each Fibonacci value is stored once in `dp[]`.
3. Avoids redundant recomputation.

---

‚ö° Ajith, do you also want me to show you the **Tabulation + Space Optimized versions** (iterative, O(1) space), so you can explain multiple approaches to an interviewer?
