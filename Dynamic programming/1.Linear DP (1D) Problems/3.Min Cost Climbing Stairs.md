Sure! Let's break down your **`Min Cost Climbing Stairs`** problem in a structured revision note style with **code explanation, dry run, time complexity, and space complexity**.

---

# 📝 Problem: Min Cost Climbing Stairs

You are given an array `cost` where `cost[i]` is the cost of step `i`. You can climb either 1 or 2 steps at a time. Find the minimum cost to reach the top of the floor (past the last step).

You can start at **step 0 or step 1**.

---

# 🔹 Approach: Recursion + Memoization (Top-Down DP)

1. Define a recursive function `solve(step)` that returns the **minimum cost to reach the top starting from `step`**.
2. Base case: If `step >= n` → reached top → return 0.
3. Memoization: Use `dp[step]` to store already computed minimum costs.
4. Transition:

   ```
   dp[step] = cost[step] + min(solve(step+1), solve(step+2))
   ```
5. The answer is `min(solve(0), solve(1))` because you can start from step 0 or 1.

---

# 🔹 Code

```cpp
class Solution { 
public:
    int solve(int step, vector<int>& dp, int n, vector<int>& cost) {
        if(step >= n) return 0; // Base case: reached top
        if(dp[step] != -1) return dp[step]; // Already computed
        
        // Choose minimum cost from 1 step or 2 steps ahead
        return dp[step] = cost[step] + min(solve(step+1, dp, n, cost), solve(step+2, dp, n, cost));
    }

    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n, -1);
        return min(solve(0, dp, n, cost), solve(1, dp, n, cost));
    }
};
```

---

# 🔹 Dry Run Example

`cost = [10, 15, 20]`

```
Step 0:
  cost[0] + min(solve(1), solve(2))
  = 10 + min(
      cost[1] + min(solve(2), solve(3)),
      cost[2] + min(solve(3), solve(4))
    )
  
Step 1:
  cost[1] + min(solve(2), solve(3))
  = 15 + min(20 + 0, 0)
  = 15

Step 2:
  cost[2] + min(solve(3), solve(4))
  = 20 + min(0,0)
  = 20

Step 0 (final):
  10 + min(15, 20) = 25

Step 1 (final):
  15 + min(20,0) = 15

Answer = min(25, 15) = 15 ✅
```

---

# 🔹 Time Complexity

* Recursive tree has **2 branches per step**.
* With memoization: each step is solved **once**.
* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(n)` for dp array + `O(n)` recursion stack → `O(n)`

---

# 🔹 Optimized Approach (Tabulation / Bottom-Up DP)

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n+1, 0); // dp[i] = min cost to reach step i
        
        for(int i=2; i<=n; i++) {
            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
        }
        
        return dp[n]; // min cost to reach the top
    }
};
```

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(n)` → can be optimized further to `O(1)` using two variables.

---

# 🔹 Optimized Space Approach (O(1) Space)

```cpp
int minCostClimbingStairs(vector<int>& cost) {
    int n = cost.size();
    int prev2 = 0, prev1 = 0;
    for(int i=2; i<=n; i++) {
        int curr = min(prev1 + cost[i-1], prev2 + cost[i-2]);
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(1)` ✅

---

If you want, I can also make a **full step-by-step diagram showing recursion tree, memoization table, and DP array updates** so you can **visualize dry run perfectly**.

Do you want me to make that diagram?
