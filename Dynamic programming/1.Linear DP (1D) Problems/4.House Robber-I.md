Got it! Your code is for the **House Robber problem**, using **Top-Down DP (recursion + memoization)**. Let‚Äôs make **quick revision notes** with code explanation, dry run, TC/SC, and interview tips.

---

# üìù Problem: House Robber

> You are a robber planning to rob houses along a street. Each house has some money.
> You **cannot rob two adjacent houses**. Find the **maximum amount you can rob**.

---

# üîπ Approach: Top-Down DP (Recursion + Memoization)

1. Define `solve(idx)` = **max money you can rob starting from house `idx`**.
2. Base case: `idx >= n` ‚Üí no houses left ‚Üí return 0.
3. Memoization: Store already computed values in `dp[idx]`.
4. Choices at house `idx`:

   * **Pick** ‚Üí rob current house: `cost[idx] + solve(idx+2)`
   * **Not Pick** ‚Üí skip current house: `solve(idx+1)`
5. Return the maximum of these two choices.
6. You can start either from house 0 or house 1.

---

# üîπ Code

```cpp
class Solution {
public:
    int solve(int idx, int n, vector<int>& cost, vector<int>& dp) {
        if(idx >= n) return 0;
        if(dp[idx] != -1) return dp[idx];

        int pick = cost[idx] + solve(idx + 2, n, cost, dp);
        int notPick = solve(idx + 1, n, cost, dp);

        return dp[idx] = max(pick, notPick);
    }

    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, -1);
        return max(solve(0, n, nums, dp), solve(1, n, nums, dp));
    }
};
```

---

# üîπ Dry Run Example

`nums = [2,7,9,3,1]`

```
solve(0):
  pick = 2 + solve(2) = 2 + 10 = 12
  notPick = solve(1) = 12
  max = 12

solve(1):
  pick = 7 + solve(3) = 7 + 1 = 8
  notPick = solve(2) = 10
  max = 10

Answer = max(solve(0), solve(1)) = max(12, 10) = 12 ‚úÖ
```

---

# üîπ Time & Space Complexity

* **Time Complexity:** `O(n)` ‚Üí each house is computed once (memoized).
* **Space Complexity:** `O(n)` for dp + `O(n)` recursion stack ‚Üí `O(n)`.

---

# üîπ Optimized Bottom-Up DP (Tabulation)

```cpp
int rob(vector<int>& nums) {
    int n = nums.size();
    if(n == 0) return 0;
    if(n == 1) return nums[0];

    vector<int> dp(n, 0);
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);

    for(int i = 2; i < n; i++) {
        dp[i] = max(nums[i] + dp[i-2], dp[i-1]);
    }

    return dp[n-1];
}
```

* **Time:** `O(n)`
* **Space:** `O(n)` ‚Üí can be reduced to `O(1)` using two variables.

---

# üîπ Space Optimized Version (O(1))

```cpp
int rob(vector<int>& nums) {
    int prev2 = 0, prev1 = 0;
    for(int num : nums) {
        int curr = max(num + prev2, prev1);
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

* **Time:** `O(n)`
* **Space:** `O(1)` ‚úÖ

---

# üîπ Interview Tips

* Always explain **choices: pick or not pick**.
* Mention **Top-Down DP** first, then **Bottom-Up / space optimization**.
* Dry run on **small examples** like `[2,7,9,3,1]`.

---

If you want, I can make a **1-page super-quick cheat sheet for all ‚Äúrob / climb stairs‚Äù type DP problems** that‚Äôs **perfect for last-minute interview revision**.

Do you want me to make that cheat sheet?
