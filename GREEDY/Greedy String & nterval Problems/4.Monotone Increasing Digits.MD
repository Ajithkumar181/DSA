Here are **concise revision notes** for **Leetcode 738: Monotone Increasing Digits**, covering **approach, dry run, time & space complexity**.

---

## âœ… Problem Summary:

Given an integer `n`, return the **largest number â‰¤ `n`** such that the digits are in **monotone increasing order** (i.e., each digit is â‰¤ the next digit).

---

## ðŸ’¡ Approach: **Greedy + Digit Manipulation**

### Key Idea:

If a digit is **greater than the digit after it**, we must:

* **Decrease** that digit by 1
* **Set all digits after it to `9`** to maximize the result while staying â‰¤ `n`

---

### ðŸ” Steps:

1. Convert `n` to a string `s` to access individual digits.
2. Traverse the string **from right to left**:

   * If `s[i] > s[i+1]`, decrease `s[i]` by 1.
   * Mark the index `i+1` â†’ all digits from here should become `'9'`.
3. After the loop, replace all digits after the mark with `'9'`.
4. Convert the result back to integer and return it.

---

## ðŸ§  Dry Run: `n = 101`

```text
s = "101"
mark = 3

i = 1: s[1]='0', s[2]='1' â†’ OK
i = 0: s[0]='1', s[1]='0' â†’ Violation:
   â†’ s[0]-- â†’ '0'
   â†’ mark = 1

Set s[1..] = '9' â†’ s = "099" â†’ stoi â†’ 99
âœ… Output = 99
```

---

## ðŸ§ª Test Cases:

| Input | Output | Explanation        |
| ----- | ------ | ------------------ |
| 10    | 9      | 1 > 0 â†’ make it 9  |
| 1234  | 1234   | Already increasing |
| 332   | 299    | 3 > 2 â†’ fix to 299 |
| 100   | 99     | 1 > 0 â†’ fix to 99  |
| 120   | 119    | 2 > 0 â†’ fix to 119 |

---

## â±ï¸ Time and Space Complexity:

### âœ… Time Complexity: `O(log N)`

* At most one pass over the number's digits.
* `log N` digits for number `N`.

### âœ… Space Complexity: `O(log N)`

* For storing the string representation of `n`.

---

## âœ… Final Code (C++):

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string s = to_string(n);
        int mark = s.size();

        for (int i = s.size() - 2; i >= 0; i--) {
            if (s[i] > s[i + 1]) {
                s[i]--;
                mark = i + 1;
            }
        }

        for (int i = mark; i < s.size(); i++) {
            s[i] = '9';
        }

        return stoi(s);
    }
};
```

---

Let me know if you want:

* A **Python version**
* More **dry runs**
* Edge case walkthroughs (like `1000`, `0`, etc.)
