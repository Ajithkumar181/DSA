Here are your clean and concise **revision notes** for **LeetCode 973 â€“ K Closest Points to Origin**:

---

## ğŸ“˜ Problem Summary

**Problem:**
Given an array of points `points[i] = [xi, yi]` on a 2D plane and an integer `k`, return the **k closest points** to the origin `(0, 0)` using **Euclidean distance**.

* Distance formula:

  $$
  \text{dist} = \sqrt{x^2 + y^2}
  $$
* You may return the answer in **any order**.

---

## âœ… Example

### ğŸ”¹ Input:

```cpp
points = [[1,3], [-2,2]], k = 1
```

### ğŸ”¹ Output:

```cpp
[[-2,2]]
```

Because:

* Distance of (1, 3) â†’ âˆš(10)
* Distance of (-2, 2) â†’ âˆš(8) â†’ Closer

---

## ğŸ”‘ Key Concepts

### âœ”ï¸ 1. **Avoid `sqrt`**

Use squared distance `xÂ² + yÂ²` for comparison (saves time and avoids precision errors).

### âœ”ï¸ 2. **Use Max-Heap of Size K**

* Push `{distance, point}` into a **max-heap**.
* If heap size > `k`, pop the farthest point.
* At the end, heap contains the **k closest points**.

---

## ğŸ§  Intuition

* Brute-force sorting â†’ `O(n log n)`
* Heap-based greedy (optimized) â†’ `O(n log k)`
* Ideal when `k << n`

---

## âœ… C++ Code (Optimal)

```cpp
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<pair<int, pair<int, int>>> pq;

        for (auto& p : points) {
            int x = p[0], y = p[1];
            int dist = x * x + y * y;
            pq.push({dist, {x, y}});
            if (pq.size() > k)
                pq.pop();  // remove farthest
        }

        vector<vector<int>> res;
        while (!pq.empty()) {
            auto [x, y] = pq.top().second;
            pq.pop();
            res.push_back({x, y});
        }

        return res;
    }
};
```

---

## â± Time and Space Complexity

| Aspect           | Complexity |
| ---------------- | ---------- |
| Time Complexity  | O(n log k) |
| Space Complexity | O(k)       |

---

## ğŸ’¡ Alternate Approaches

### ğŸ”¸ 1. **Sort + Slice**

* Compute all distances.
* Sort all points.
* Return first `k`.

ğŸ”¹ Time: `O(n log n)`

---

### ğŸ”¸ 2. **QuickSelect (Average O(n))**

* Partial sort based on k-th smallest distance.
* Very efficient, but harder to implement.

---

## ğŸ§ª Constraints

* `1 <= k <= points.length <= 10â´`
* `-10â´ <= xi, yi <= 10â´`

---

## ğŸ“š Related Problems

| Problem                             | Type                 |
| ----------------------------------- | -------------------- |
| **LC 215. Kth Largest Element**     | Top K with max-heap  |
| **LC 347. Top K Frequent Elements** | Frequency + heap     |
| **LC 692. Top K Frequent Words**    | Lexicographic + heap |

---

## âœ… Summary Table

| Approach     | Time       | Space | Best Use Case          |
| ------------ | ---------- | ----- | ---------------------- |
| Sorting      | O(n log n) | O(n)  | Simple & small inputs  |
| Max-Heap (k) | O(n log k) | O(k)  | Large input, small `k` |
| QuickSelect  | Avg O(n)   | O(1)  | Advanced & efficient   |

---

Let me know if you'd like:

* A dry run
* QuickSelect version
* Python version
* Practice worksheet
