Here are your clean and concise **revision notes** for **LeetCode 973 â€“ K Closest Points to Origin**:

---

## ğŸ“˜ Problem Summary

**Problem:**
Given an array of points `points[i] = [xi, yi]` on a 2D plane and an integer `k`, return the **k closest points** to the origin `(0, 0)` using **Euclidean distance**.

* Distance formula:

  $$
  \text{dist} = \sqrt{x^2 + y^2}
  $$
* You may return the answer in **any order**.

---

## âœ… Example

### ğŸ”¹ Input:

```cpp
points = [[1,3], [-2,2]], k = 1
```

### ğŸ”¹ Output:

```cpp
[[-2,2]]
```

Because:

* Distance of (1, 3) â†’ âˆš(10)
* Distance of (-2, 2) â†’ âˆš(8) â†’ Closer

---

## ğŸ”‘ Key Concepts

### âœ”ï¸ 1. **Avoid `sqrt`**

Use squared distance `xÂ² + yÂ²` for comparison (saves time and avoids precision errors).

### âœ”ï¸ 2. **Use Max-Heap of Size K**

* Push `{distance, point}` into a **max-heap**.
* If heap size > `k`, pop the farthest point.
* At the end, heap contains the **k closest points**.

---

## ğŸ§  Intuition

* Brute-force sorting â†’ `O(n log n)`
* Heap-based greedy (optimized) â†’ `O(n log k)`
* Ideal when `k << n`

---

## âœ… C++ Code (Optimal)

```cpp
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<pair<int, pair<int, int>>> pq;

        for (auto& p : points) {
            int x = p[0], y = p[1];
            int dist = x * x + y * y;
            pq.push({dist, {x, y}});
            if (pq.size() > k)
                pq.pop();  // remove farthest
        }

        vector<vector<int>> res;
        while (!pq.empty()) {
            auto [x, y] = pq.top().second;
            pq.pop();
            res.push_back({x, y});
        }

        return res;
    }
};
```

---

## â± Time and Space Complexity

| Aspect           | Complexity |
| ---------------- | ---------- |
| Time Complexity  | O(n log k) |
| Space Complexity | O(k)       |

---

## ğŸ’¡ Alternate Approaches

### ğŸ”¸ 1. **Sort + Slice**

* Compute all distances.
* Sort all points.
* Return first `k`.

ğŸ”¹ Time: `O(n log n)`

---

### ğŸ”¸ 2. **QuickSelect (Average O(n))**

* Partial sort based on k-th smallest distance.
* Very efficient, but harder to implement.

---

## ğŸ§ª Constraints

* `1 <= k <= points.length <= 10â´`
* `-10â´ <= xi, yi <= 10â´`

---

## ğŸ“š Related Problems

| Problem                             | Type                 |
| ----------------------------------- | -------------------- |
| **LC 215. Kth Largest Element**     | Top K with max-heap  |
| **LC 347. Top K Frequent Elements** | Frequency + heap     |
| **LC 692. Top K Frequent Words**    | Lexicographic + heap |

---

## âœ… Summary Table

| Approach     | Time       | Space | Best Use Case          |
| ------------ | ---------- | ----- | ---------------------- |
| Sorting      | O(n log n) | O(n)  | Simple & small inputs  |
| Max-Heap (k) | O(n log k) | O(k)  | Large input, small `k` |
| QuickSelect  | Avg O(n)   | O(1)  | Advanced & efficient   |

---

Let me know if you'd like:

* A dry run
* QuickSelect version
* Python version
* Practice worksheet


Hereâ€™s a **dry run** of the C++ **heap-based approach** for **LeetCode 973 â€“ K Closest Points to Origin**:

---

## ğŸ§ª Dry Run

### ğŸ”¹ Input:

```cpp
points = [[1, 3], [-2, 2], [2, -2]], k = 2
```

---

### ğŸ“Œ Step-by-Step Execution:

We use a **max-heap** to store at most `k = 2` closest points.

We push points with their **squared distance** as the key.

---

### ğŸ” Iteration 1: Point = `[1, 3]`

* Squared Distance: `1Â² + 3Â² = 10`
* Push: `(10, {1, 3})`
* Heap: `[(10, {1, 3})]`

---

### ğŸ” Iteration 2: Point = `[-2, 2]`

* Squared Distance: `(-2)Â² + 2Â² = 8`
* Push: `(8, {-2, 2})`
* Heap: `[(10, {1, 3}), (8, {-2, 2})]` â†’ max-heap sorts by largest distance on top

---

### ğŸ” Iteration 3: Point = `[2, -2]`

* Squared Distance: `2Â² + (-2)Â² = 8`
* Push: `(8, {2, -2})`
* Heap size becomes 3 > `k = 2`, so we **pop** the farthest point

Farthest = `(10, {1, 3})` â†’ Removed

* Heap after pop: `[(8, {-2, 2}), (8, {2, -2})]`

---

### ğŸ“¤ Final Heap Content:

```cpp
[(8, {-2, 2}), (8, {2, -2})]
```

Now we extract points from the heap:

* Output: `[{-2, 2}, {2, -2}]` (order can vary)

---

### âœ… Final Answer:

```cpp
[[-2, 2], [2, -2]]
```

---

### â± Heap Operations Summary:

| Operation     | Description                             |
| ------------- | --------------------------------------- |
| Push          | Add each point with squared distance    |
| Pop (if > k)  | Remove the farthest point if heap > k   |
| Final Extract | Return the remaining `k` closest points |

---

Let me know if you'd like a **QuickSelect dry run**, **visual diagram**, or a **practice problem worksheet** on this topic.
