Here's a clean and concise **ğŸ“˜ Revision Notes** for **LeetCode 692: Top K Frequent Words** to help you quickly review the problem, logic, and solution approaches:

---

# ğŸ§  LeetCode 692: Top K Frequent Words â€” Revision Notes

## ğŸ“„ Problem Summary

Given a list of words and an integer `k`, return the `k` most frequent words.

* Sort by **descending frequency**
* If frequencies are equal, use **lexicographical order**

### ğŸ” Examples

**Input:**

```cpp
words = ["i","love","leetcode","i","love","coding"], k = 2
```

**Output:**

```cpp
["i","love"]
```

---

## âœ… Constraints

* `1 <= words.length <= 500`
* `1 <= words[i].length <= 10`
* `words[i]` contains only lowercase English letters
* `k` is between 1 and number of unique words

---

## âš™ï¸ Core Concepts Involved

* Hash Map for frequency counting (`O(n)`)
* Min/Max Heap for top K selection (`O(n log k)` or `O(n log n)`)
* Lexicographical sorting for ties

---

## ğŸ”‘ Approaches

### ğŸ”¸ 1. **Max-Heap with Custom Comparator** (Easy to write, `O(n log n)`)

* Build frequency map
* Push all word-frequency pairs into a **max-heap**
* Use comparator:

  * Higher frequency = higher priority
  * If equal frequency â†’ lexicographically **smaller** word has higher priority

```cpp
auto cmp = [](const pair<int, string>& a, const pair<int, string>& b) {
    if (a.first == b.first)
        return a.second > b.second;  // lex smaller first
    return a.first < b.first;       // high freq first
};
```

* Extract top `k` elements

### ğŸ”¸ 2. **Min-Heap of Size k** (Optimal: `O(n log k)` time, `O(k)` space)

* Keep only the top `k` elements in the heap
* Pop smallest when size > k
* Final heap has desired top `k` words
* Reverse the result to get proper ordering

---

## ğŸ§  Key Points

| Step               | Technique           | Time                         |
| ------------------ | ------------------- | ---------------------------- |
| Count freq         | Hash Map            | `O(n)`                       |
| Heap insert        | Min-Heap / Max-Heap | `O(n log k)` or `O(n log n)` |
| Final sort/reverse | For correct order   | `O(k log k)` or `O(k)`       |

---

## ğŸ” Follow-up: `O(n log k)`?

* Use **min-heap** to keep top `k` elements during iteration
* Avoid full sort or full heap of all `n` items
* Great for large inputs when `k` â‰ª `n`

---

## âœ… Final Code (C++ Max Heap with Custom Comparator)

```cpp
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> freq;
        for (string& w : words)
            freq[w]++;

        auto cmp = [](const pair<int, string>& a, const pair<int, string>& b) {
            if (a.first == b.first)
                return a.second > b.second;
            return a.first < b.first;
        };

        priority_queue<pair<int, string>, vector<pair<int, string>>, decltype(cmp)> pq(cmp);

        for (auto& [word, count] : freq)
            pq.push({count, word});

        vector<string> res;
        while (k--) {
            res.push_back(pq.top().second);
            pq.pop();
        }

        return res;
    }
};
```

---

## ğŸ’¡ Tip for Interviews

* Explain tradeoffs between **heap** vs **sort**
* Justify your comparator carefully
* Be ready to explain why `a.second > b.second` gives **lexical ascending** order

---

Let me know if youâ€™d like:

* ğŸ§ª Dry run with a sample input
* ğŸ“Œ Python version
* ğŸ’­ How to implement with sorting instead of heap
