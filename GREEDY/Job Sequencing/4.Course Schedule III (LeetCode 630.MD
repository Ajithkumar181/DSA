Hereâ€™s a **quick revision note** for **LeetCode 630 â€“ Course Schedule III**.

---

## ğŸ§  **Problem Summary**

You are given `courses[i] = [duration, lastDay]`.
Each course takes `duration` days and **must be completed on or before `lastDay`**.
You start at day 1 and **cannot take overlapping courses**.

ğŸ‘‰ **Goal**: Return the **maximum number of courses** you can take.

---

## ğŸ”‘ **Core Idea**

Take as many courses as possible without exceeding their deadlines.
Use a **greedy approach** to:

1. Take earlier-deadline courses first.
2. If the total duration exceeds the current deadline, **drop the longest course taken so far**.

---

## ğŸ› ï¸ **Approach**

### Step-by-Step:

1. **Sort** the courses by `lastDay` (deadline).
2. Use a **max-heap** to keep durations of selected courses.
3. For each course:

   * Add its `duration` to `totalDay`.
   * If `totalDay > lastDay`, pop the **longest course** to stay within time.

### Why Max-Heap?

To **drop the longest-duration course** when the schedule exceeds the deadline.

---

## ğŸ§¾ **Example**

### Input:

```
[[100,200],[200,1300],[1000,1250],[2000,3200]]
```

### Sorted by deadline:

```
[100,200], [1000,1250], [200,1300], [2000,3200]
```

### Greedy Simulation:

* Take 100 â†’ total = 100
* Take 1000 â†’ total = 1100
* Take 200 â†’ total = 1300
* Can't take 2000 (would go to 3300 > 3200)
  âœ… Answer: **3 courses**

---

## ğŸ’» **Code (C++)**

```cpp
class Solution {
public:
    int scheduleCourse(vector<vector<int>>& courses) {
        sort(courses.begin(), courses.end(), [](auto &a, auto &b) {
            return a[1] < b[1]; // sort by deadline
        });

        priority_queue<int> pq;
        int totalDay = 0;

        for (auto &course : courses) {
            totalDay += course[0];
            pq.push(course[0]);

            if (totalDay > course[1]) {
                totalDay -= pq.top(); // drop longest course
                pq.pop();
            }
        }

        return pq.size(); // number of courses taken
    }
};
```

---

## ğŸ“¦ **Time & Space Complexity**

| Type     | Complexity                                    |
| -------- | --------------------------------------------- |
| ğŸ•’ Time  | O(N log N) for sort + O(N log N) for heap ops |
| ğŸ§  Space | O(N) for heap                                 |

---

## âœ… Tips for Interviews

* Always sort by deadline for scheduling-type problems.
* Use max-heap to drop the heaviest/longest course.
* Greedy strategy works here due to **non-overlapping constraint**.

---

Let me know if you want:

* ğŸ§ª Python version
* ğŸ“ Practice problems similar to this
* ğŸ“Š Visual dry-run example of heap operations
