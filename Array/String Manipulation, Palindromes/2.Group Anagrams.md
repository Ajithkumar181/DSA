Here are the **revision notes with dry run**, **time complexity (TC)**, and **space complexity (SC)** for your solution to **Group Anagrams**:

---

## âœ… Problem: Group Anagrams

Given an array of strings, group the anagrams together.

### ðŸ”¹Definition:

Anagrams are words formed by rearranging the same letters.
Example: `"eat"`, `"tea"`, `"ate"` are all anagrams of each other.

---

## âœ… Approach Used:

**Sorting-based grouping using Hash Map**

---

## âœ… Code:

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;

        for (auto& it : strs) {
            string res = it;
            sort(res.begin(), res.end());      // Sort each word
            mp[res].push_back(it);             // Group by sorted string
        }

        vector<vector<string>> res;
        for (auto& it : mp) {
            res.push_back(it.second);          // Collect grouped anagrams
        }

        return res;
    }
};
```

---

## âœ… Dry Run

### Input:

```cpp
strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
```

### Iteration-wise breakdown:

1. `"eat"` â†’ sorted = `"aet"` â†’ mp\["aet"] = \["eat"]
2. `"tea"` â†’ sorted = `"aet"` â†’ mp\["aet"] = \["eat", "tea"]
3. `"tan"` â†’ sorted = `"ant"` â†’ mp\["ant"] = \["tan"]
4. `"ate"` â†’ sorted = `"aet"` â†’ mp\["aet"] = \["eat", "tea", "ate"]
5. `"nat"` â†’ sorted = `"ant"` â†’ mp\["ant"] = \["tan", "nat"]
6. `"bat"` â†’ sorted = `"abt"` â†’ mp\["abt"] = \["bat"]

### Final `mp`:

```
{
  "aet": ["eat", "tea", "ate"],
  "ant": ["tan", "nat"],
  "abt": ["bat"]
}
```

### Output:

```cpp
[
  ["eat", "tea", "ate"],
  ["tan", "nat"],
  ["bat"]
]
```

---

## âœ… Time Complexity (TC):

Let:

* `n` = number of strings in `strs`
* `k` = average length of each string

| Step                         | Time Complexity       |
| ---------------------------- | --------------------- |
| Sorting each string          | O(k log k) per string |
| Total sorting                | O(n \* k log k)       |
| Hashing and pushing to map   | O(n \* k)             |
| Constructing result from map | O(n)                  |
| **Total TC**                 | **O(n \* k log k)**   |

---

## âœ… Space Complexity (SC):

| Component                        | Space                |
| -------------------------------- | -------------------- |
| Hash map to store anagram groups | O(n \* k)            |
| Output vector                    | O(n \* k)            |
| Temp string for sorting          | O(k) (per iteration) |
| **Total SC**                     | **O(n \* k)**        |

---

## âœ… Summary

| Aspect           | Value                               |
| ---------------- | ----------------------------------- |
| Technique        | Sorting + Hash Map                  |
| Time Complexity  | O(n \* k log k)                     |
| Space Complexity | O(n \* k)                           |
| Best Use Case    | When strings are short (k is small) |
| Pros             | Clean, simple, and effective        |
| Cons             | Sorting overhead for long strings   |

---

Let me know if you want the **frequency-count optimization** or a **Java/Python** version!
