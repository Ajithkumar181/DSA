Here are your **revision notes with dry run, time complexity (TC), and space complexity (SC)** for the `isIsomorphic` function:

---

## ✅ Problem: **Isomorphic Strings**

Two strings `s` and `t` are **isomorphic** if the characters in `s` can be replaced to get `t` **in a consistent one-to-one mapping** while preserving order.

---

## ✅ Code:

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        vector<int> freq1(128, 0); // Tracks last index seen for characters in s
        vector<int> freq2(128, 0); // Tracks last index seen for characters in t
        
        if (s.size() != t.size()) return false;

        for (int i = 0; i < s.size(); i++) {
            if (freq1[s[i]] != freq2[t[i]]) return false;

            freq1[s[i]] = i + 1;
            freq2[t[i]] = i + 1;
        }

        return true;
    }
};
```

---

## ✅ Dry Run

### Input:

```cpp
s = "egg"
t = "add"
```

### Step-by-Step:

| i | s\[i] | t\[i] | freq1\[s\[i]] | freq2\[t\[i]] | Compare | Action         |
| - | ----- | ----- | ------------- | ------------- | ------- | -------------- |
| 0 | e     | a     | 0             | 0             | ✅       | Set to i+1 → 1 |
| 1 | g     | d     | 0             | 0             | ✅       | Set to i+1 → 2 |
| 2 | g     | d     | 2             | 2             | ✅       | Set to i+1 → 3 |

### Final Result: ✅ `true` (Isomorphic)

---

### Edge Case:

```cpp
s = "foo"
t = "bar"
```

| i | s\[i] | t\[i] | freq1\[s\[i]] | freq2\[t\[i]] | Compare | Result         |
| - | ----- | ----- | ------------- | ------------- | ------- | -------------- |
| 0 | f     | b     | 0             | 0             | ✅       | Set            |
| 1 | o     | a     | 0             | 0             | ✅       | Set            |
| 2 | o     | r     | 2             | 0             | ❌       | Return `false` |

---

## ✅ Key Insight

* We **store the last position (i + 1)** each character was seen in `s` and `t`.
* If the last-seen positions **don’t match**, the mapping is **inconsistent**, so return `false`.

---

## ✅ Time Complexity (TC)

* Loop runs once through `s` and `t` → **O(n)** where `n = s.size()`

## ✅ Space Complexity (SC)

* `vector<int> freq1(128)` and `freq2(128)` → **O(1)** (constant space, fixed size for ASCII)

---

## ✅ Summary Table

| Item              | Value                                       |
| ----------------- | ------------------------------------------- |
| Time Complexity   | **O(n)**                                    |
| Space Complexity  | **O(1)** (fixed array of size 128)          |
| Approach          | Store **last-seen index** for mapping check |
| Works for         | All ASCII characters                        |
| Input Assumption  | `s` and `t` contain ASCII chars only        |
| Pattern Validated | Position-based 1-to-1 mapping               |

---

## ✅ Why `i+1` instead of `i`?

We initialize vectors with `0`. If we used `i`, then `i=0` and "not seen yet" would **both be 0**, causing false matches.

So, using `i + 1` helps differentiate between:

* **"not seen yet"** → 0
* **"seen at position 0"** → 1

---

Let me know if you’d like the same notes in **Java**, or want to handle **Unicode/UTF-8** inputs too!
