Certainly! Here are the detailed **revision notes** for the given code that counts how many permutations of a pattern `pat` occur as substrings in the text `txt`. This is similar to the previous problem but now we count **all occurrences**.

---

# Revision Notes: Count Permutation Occurrences of Pattern in Text

---

### Problem Summary:

Given two strings `pat` (pattern) and `txt` (text), count the number of substrings in `txt` that are permutations of `pat`.

---

### Approach Overview:

* Use a **sliding window** of length `pat.size()` on `txt`.
* Keep frequency counts of characters in `pat` and current window of `txt`.
* Slide over `txt`, compare frequency arrays to detect if current window is a permutation.
* Count every window that matches the pattern's frequency.

---

### Code Explanation:

```cpp
class Solution {
public:
    int search(string &pat, string &txt) {
        if (pat.size() > txt.size()) return 0;

        vector<int> freq1(26, 0); // frequency of chars in pat
        vector<int> freq2(26, 0); // frequency of chars in current window of txt

        // Count frequency of pattern chars
        for (char ch : pat) freq1[ch - 'a']++;

        // Initialize frequency for the first window of txt
        for (int i = 0; i < pat.size(); i++) freq2[txt[i] - 'a']++;

        int count = 0;
        if (freq1 == freq2) count++; // check first window

        int i = 0; // left pointer of the sliding window
        for (int j = pat.size(); j < txt.size(); j++) {
            freq2[txt[i] - 'a']--;   // remove leftmost char of window
            freq2[txt[j] - 'a']++;   // add next char on right of window
            i++;                     // slide window forward

            if (freq1 == freq2) count++; // check if new window matches
        }

        return count;
    }
};
```

---

### Dry Run Example:

`pat = "abc"`, `txt = "cbabcacab"`

| Step | Window Indices | Window String | freq2 matches freq1? (abc freq) | Count So Far |
| ---- | -------------- | ------------- | ------------------------------- | ------------ |
| Init | 0 to 2         | "cba"         | Yes                             | 1            |
| 1    | 1 to 3         | "bab"         | No                              | 1            |
| 2    | 2 to 4         | "abc"         | Yes                             | 2            |
| 3    | 3 to 5         | "bca"         | Yes                             | 3            |
| 4    | 4 to 6         | "cac"         | No                              | 3            |
| 5    | 5 to 7         | "aca"         | No                              | 3            |
| 6    | 6 to 8         | "cab"         | Yes                             | 4            |

Result = 4 permutations found.

---

### Time Complexity:

* Initial frequency counts: **O(m)**, m = length of `pat`.
* Sliding over `txt`: **O(n - m)**, n = length of `txt`.
* Comparing frequency arrays each step: **O(26)** (constant).
* Overall time complexity: **O(n)** linear time.

---

### Space Complexity:

* Two frequency arrays of size 26 â†’ **O(1)** constant space.

---

### Summary:

* Efficient sliding window technique used to find and count permutations.
* Frequency arrays track characters for quick comparison.
* Constant-time frequency comparison due to fixed alphabet size.
* Handles counting all valid windows, not just detecting one.

---

If you'd like, I can help you practice explaining this to an interviewer too!
