Here are your **revision notes** with a clear **dry run** for:

---

# âœ… LeetCode 424. Longest Repeating Character Replacement

---

## ğŸ”¸ Problem Summary:

You are given:

* A string `s` of uppercase letters (Aâ€“Z)
* An integer `k` representing the **maximum number of characters you can replace**

ğŸ§  Goal: Find the **length of the longest substring** where you can **replace at most `k` characters** to make all characters **the same**.

---

## ğŸ“˜ Example:

### Input:

```
s = "AABABBA"
k = 1
```

### Output:

```
4
```

### Explanation:

We can replace one `'A'` to `'B'` in `"ABBA"` or `"BABB"` to make `"BBBB"` â€” length = 4.

---

## ğŸ”§ Key Concepts:

### âœ… Sliding Window Technique

* Maintain a window `[left, right]` in the string
* Track:

  * `freq[26]`: Frequency of characters in window
  * `maxFreq`: Max frequency of any character in window
* Valid Window Condition:

  ```
  window size - maxFreq â‰¤ k
  ```

  â†’ Only `k` characters need to be replaced

---

## âœ… Final Code (C++)

```cpp
class Solution {
public:
    int characterReplacement(string s, int k) {
        vector<int> freq(26, 0);
        int left = 0, maxFreq = 0, maxLen = 0;

        for (int right = 0; right < s.size(); ++right) {
            freq[s[right] - 'A']++;
            maxFreq = max(maxFreq, freq[s[right] - 'A']);

            int windowSize = right - left + 1;

            if (windowSize - maxFreq > k) {
                freq[s[left] - 'A']--;
                left++;
            }

            maxLen = max(maxLen, right - left + 1);
        }

        return maxLen;
    }
};
```

---

## ğŸ§ª Dry Run on `"AABABBA", k = 1`

Weâ€™ll track:

| Step | Left | Right | Char | Window | MaxFreq | Replace Count = `Window - MaxFreq` | Action          | MaxLen |
| ---- | ---- | ----- | ---- | ------ | ------- | ---------------------------------- | --------------- | ------ |
| 0    | 0    | 0     | A    | A      | 1       | 0 â‰¤ 1 âœ…                            | Expand          | 1      |
| 1    | 0    | 1     | A    | AA     | 2       | 0 â‰¤ 1 âœ…                            | Expand          | 2      |
| 2    | 0    | 2     | B    | AAB    | 2       | 1 â‰¤ 1 âœ…                            | Expand          | 3      |
| 3    | 0    | 3     | A    | AABA   | 3       | 1 â‰¤ 1 âœ…                            | Expand          | 4      |
| 4    | 0    | 4     | B    | AABAB  | 3       | 2 > 1 âŒ                            | Shrink â†’ left++ | 4      |
| 5    | 1    | 4     |      | ABAB   | 2       | 2 > 1 âŒ                            | Shrink â†’ left++ | 4      |
| 6    | 2    | 4     |      | BAB    | 2       | 1 â‰¤ 1 âœ…                            | Expand          | 3      |
| 7    | 2    | 5     | B    | BABB   | 3       | 1 â‰¤ 1 âœ…                            | Expand          | 4      |
| 8    | 2    | 6     | A    | BABBA  | 3       | 2 > 1 âŒ                            | Shrink â†’ left++ | 4      |
| 9    | 3    | 6     |      | ABBA   | 2       | 2 > 1 âŒ                            | Shrink â†’ left++ | 4      |
| 10   | 4    | 6     |      | BBA    | 2       | 1 â‰¤ 1 âœ…                            | Expand          | âœ… 4    |

---

## ğŸ§  Key Insight:

* The trick is to always maintain the window such that we never need to replace more than `k` characters.
* `maxFreq` is **not recomputed** when left moves â€” this is acceptable because the window still works correctly.
* The result is tracked using `maxLen`.

---

## ğŸ§® Time & Space Complexity:

| Complexity | Value |
| ---------- | ----- |
| â±ï¸ Time    | O(n)  |
| ğŸ§  Space   | O(1)  |

Why? Only 26 uppercase letters â†’ `freq[26]`.

---

Let me know if you want a **visual animation**, **Python/Java version**, or practice problems based on this!
