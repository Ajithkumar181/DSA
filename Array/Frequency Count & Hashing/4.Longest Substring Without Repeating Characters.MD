Here are **revision notes with a dry run** for your code that solves the classic sliding window problem:

---

## 📘 **Problem: Length of Longest Substring Without Repeating Characters**

---

### ✅ Problem Statement

Given a string `s`, find the **length of the longest substring** without repeating characters.

---

### 🔍 Example

#### Input:

```
s = "abcabcbb"
```

#### Output:

```
3 → "abc" is the longest substring without repeating characters
```

---

### ⚙️ Approach: **Sliding Window + Hash Map**

```cpp
unordered_map<char, int> mp;  // To count characters in current window
int i = 0, cnt = 0;

for (int j = 0; j < s.size(); j++) {
    mp[s[j]]++;  // Add current character

    // If a duplicate is found, shrink the window from the left
    while (mp[s[j]] > 1) {
        mp[s[i]]--;
        i++;
    }

    cnt = max(cnt, j - i + 1);  // Update max length
}
```

---

## 🧠 Explanation

We are keeping a **window \[i...j]** where:

* All characters are **unique**
* If we see a **duplicate**, we shrink from the left

We use a hash map `mp` to **track the count** of characters in the window.

---

## 🧪 Dry Run

### Input:

```cpp
s = "abcabcbb"
```

### Initialization:

* `i = 0`, `cnt = 0`, `mp = {}`

| j | s\[j] | Action                          | i | mp              | cnt |
| - | ----- | ------------------------------- | - | --------------- | --- |
| 0 | a     | insert 'a', window = "a"        | 0 | {a:1}           | 1   |
| 1 | b     | insert 'b', window = "ab"       | 0 | {a:1, b:1}      | 2   |
| 2 | c     | insert 'c', window = "abc"      | 0 | {a:1, b:1, c:1} | 3   |
| 3 | a     | duplicate 'a' → shrink from i=0 | 1 | {a:1, b:1, c:1} | 3   |
| 4 | b     | duplicate 'b' → shrink from i=1 | 2 | {a:1, b:1, c:1} | 3   |
| 5 | c     | duplicate 'c' → shrink from i=2 | 3 | {a:1, b:1, c:1} | 3   |
| 6 | b     | insert 'b', window = "cab"      | 3 | {a:1, b:1, c:1} | 3   |
| 7 | b     | duplicate 'b' → shrink from i=3 | 5 | {a:0, b:1, c:0} | 3   |

✔️ Final Answer: `3`

---

## 🔁 Time & Space Complexity

| Metric           | Value                                        |
| ---------------- | -------------------------------------------- |
| Time Complexity  | O(n)                                         |
| Space Complexity | O(min(n, 26)) (since only lowercase letters) |

---

## 📚 Summary

| Concept        | Description                                           |
| -------------- | ----------------------------------------------------- |
| Sliding Window | Maintains a window without repeating characters       |
| Hash Map       | Tracks frequency of each character in the window      |
| When duplicate | Shrink window from left (`i++`) until valid again     |
| Update max     | On every valid window, update `cnt = max(cnt, j-i+1)` |

---

## ✅ Final Clean Code (your code is perfect)

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> mp;
        int cnt = 0;
        int i = 0;
        for (int j = 0; j < s.size(); j++) {
            mp[s[j]]++;
            while (mp[s[j]] > 1) {
                mp[s[i]]--;
                i++;
            }
            cnt = max(cnt, j - i + 1);
        }
        return cnt;
    }
};
```

---

Would you like:

* A version using an unordered\_set?
* A visual diagram to explain the sliding window?
* More practice problems like this one?
