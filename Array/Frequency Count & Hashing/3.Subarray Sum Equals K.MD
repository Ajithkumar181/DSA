Here's a complete **revision note with dry run** for the popular problem:

---

## 📘 **Problem: Subarray Sum Equals K**

Leetcode: [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)

---

### ✅ **Problem Statement**

Given an integer array `nums` and an integer `k`, return the total number of **continuous subarrays** whose **sum equals to `k`**.

---

### 🔍 **Key Concepts**

* **Prefix Sum**: Sum of elements from start to index `i`
* **Hash Map (unordered\_map)**: Stores how many times a prefix sum has appeared

---

### ⚙️ **Approach (Optimal O(n) using Prefix Sum + Hash Map)**

```cpp
unordered_map<int, int> mp;
mp[0] = 1; // base case: one subarray with sum 0
int prefix = 0;
int count = 0;

for (int i = 0; i < n; i++) {
    prefix += nums[i];

    // Check if there's a prefix sum we saw before such that:
    // prefix - (prefix - k) = k
    if (mp.count(prefix - k)) {
        count += mp[prefix - k];
    }

    // Record current prefix sum
    mp[prefix]++;
}
```

---

## 🧪 **Dry Run Example**

### Input:

```cpp
nums = [1, 2, 3], k = 3
```

### Expected Output:

```
2 → subarrays: [1,2] and [3]
```

---

### Step-by-Step:

| i | nums\[i] | prefix = prefix + nums\[i] | prefix - k | mp\[prefix - k] | count | mp after this step   |
| - | -------- | -------------------------- | ---------- | --------------- | ----- | -------------------- |
| 0 | 1        | 1                          | -2         | 0               | 0     | {0:1, 1:1}           |
| 1 | 2        | 3                          | 0          | 1               | 1     | {0:1, 1:1, 3:1}      |
| 2 | 3        | 6                          | 3          | 1               | 2     | {0:1, 1:1, 3:1, 6:1} |

✅ Output: `2`

---

## 🧠 **Why This Works**

We want to count all subarrays ending at index `i` that sum to `k`.

* Let `prefix` be the sum from index `0` to `i`.
* If there exists a `prefix - k` in the map, it means a subarray with sum `k` ends at `i`.
* Add the number of times `(prefix - k)` occurred to the result.

---

## 🛠️ **Time & Space Complexity**

| Measure          | Value             |
| ---------------- | ----------------- |
| Time Complexity  | O(n)              |
| Space Complexity | O(n) (worst case) |

---

## 📚 Summary

| Concept     | Explanation                                                        |
| ----------- | ------------------------------------------------------------------ |
| Prefix Sum  | Keeps running sum from left to right                               |
| Hash Map    | Stores how many times each prefix sum has occurred                 |
| Count Logic | If `prefix - k` was seen before, a subarray with sum `k` ends here |
| Edge Case   | Initialize `mp[0] = 1` to handle full prefix sums equal to `k`     |

---

### ✅ Final Clean Code (Same as yours)

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        mp[0] = 1;
        int prefix = 0, cnt = 0;

        for (int i = 0; i < nums.size(); i++) {
            prefix += nums[i];
            if (mp.count(prefix - k)) {
                cnt += mp[prefix - k];
            }
            mp[prefix]++;
        }

        return cnt;
    }
};
```

---

Would you like practice questions or visuals for this concept?
