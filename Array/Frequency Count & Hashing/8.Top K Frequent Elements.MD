Here are **revision notes with dry run** for the C++ program using a **HashMap** and **Max Heap** to find the **Top K Frequent Elements**.

---

### 🔍 **Problem Statement**

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements.

---

### 🧠 **Concepts Used**

1. **HashMap (`unordered_map`)**: Count the frequency of each element.
2. **Max Heap (`priority_queue`)**: Store frequency and element pairs, sorted by highest frequency.
3. Extract the top `k` elements from the heap.

---

### 🧾 **Code Summary**

```cpp
unordered_map<int, int> mp;      // Count frequencies
for (auto& it : nums) {
    mp[it]++;
}

priority_queue<pair<int, int>> pq;   // Max Heap based on frequency
for (auto& it : mp) {
    pq.push({it.second, it.first}); // (freq, element)
}

vector<int> res;
while (k-- > 0) {
    res.push_back(pq.top().second);
    pq.pop();
}
return res;
```

---

### 🧪 **Dry Run Example**

```cpp
nums = [1,1,1,2,2,3], k = 2
```

#### Step 1: Frequency Map

```cpp
mp = {
  1: 3,
  2: 2,
  3: 1
}
```

#### Step 2: Priority Queue (Max Heap)

The heap stores `{frequency, number}`:

```cpp
pq = [
  {3, 1},
  {2, 2},
  {1, 3}
] (top = 3,1)
```

#### Step 3: Extract Top K

* Pop `{3, 1}` → `res = [1]`
* Pop `{2, 2}` → `res = [1, 2]`

✅ Final result: `[1, 2]`

---

### ⏱️ **Time Complexity**

* Building map: `O(n)`
* Heap push: `O(m log m)` where `m` = number of unique elements.
* Extract top `k`: `O(k log m)`

> Total: **`O(n + m log m)`**, where `m` ≤ `n`.

### 📦 **Space Complexity**

* HashMap: `O(m)`
* Heap: `O(m)`
* Result: `O(k)`

---

### ✅ Tips

* You can use **Min Heap** for more optimized solution when `k << m`.
* To sort elements by increasing frequency, use a **Min Heap** with custom comparator.

---

Let me know if you'd like a version with inline comments or Min Heap optimization.
