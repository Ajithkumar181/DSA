Here's a concise and clear **revision note** with **dry run** for your provided solution to **Leetcode 118. Pascal’s Triangle**:

---

## ✅ **Revision Notes: Pascal's Triangle (Leetcode 118)**

### 🔶 **Problem Statement:**

Given an integer `numRows`, return the first `numRows` of Pascal's Triangle.

---

### 📘 **Key Concept:**

* Each element in row `i` and column `j` is:

  $$
  C(i-1, j-1) = \frac{(i-1)!}{(j-1)! \cdot (i-j)!}
  $$
* Formula used in code:

  $$
  C(n, r) = C(n, r-1) \cdot \frac{n-r+1}{r}
  $$

---

### ✅ **Code Summary:**

```cpp
class Solution {
public:
    vector<int> pascal(int i){
        vector<int> res;
        res.push_back(1); // First value in row is always 1

        for(int j = 1; j < i; j++){
            int val = res.back(); // Last computed value
            res.push_back(val * (i - j) / j); // Use formula for next binomial
        }
        return res;
    }

    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        for(int i = 1; i <= numRows; i++){
            res.push_back(pascal(i)); // Compute ith row
        }
        return res;
    }
};
```

---

### 🔍 **Dry Run for numRows = 4**

#### Call: `generate(4)`

---

1. **i = 1** → `pascal(1)`

   * res = \[1]
   * return `[1]`

2. **i = 2** → `pascal(2)`

   * res = \[1]
   * j = 1:

     * val = 1
     * new = 1 × (2 - 1) / 1 = 1
     * res = \[1, 1]
   * return `[1, 1]`

3. **i = 3** → `pascal(3)`

   * res = \[1]
   * j = 1:

     * val = 1 × (3 - 1) / 1 = 2
     * res = \[1, 2]
   * j = 2:

     * val = 2 × (3 - 2) / 2 = 1
     * res = \[1, 2, 1]
   * return `[1, 2, 1]`

4. **i = 4** → `pascal(4)`

   * res = \[1]
   * j = 1:

     * val = 1 × (4 - 1) / 1 = 3
     * res = \[1, 3]
   * j = 2:

     * val = 3 × (4 - 2) / 2 = 3
     * res = \[1, 3, 3]
   * j = 3:

     * val = 3 × (4 - 3) / 3 = 1
     * res = \[1, 3, 3, 1]
   * return `[1, 3, 3, 1]`

---

### ✅ **Final Output:**

```cpp
[
 [1],
 [1, 1],
 [1, 2, 1],
 [1, 3, 3, 1]
]
```

---

### 🧠 **Time & Space Complexity:**

* **Time:** `O(numRows^2)`
  (We compute each element once using the combinatoric formula)
* **Space:** `O(numRows^2)`
  (Required to store the result)

---

Let me know if you want to add debug prints or visualize this with a triangle diagram.
