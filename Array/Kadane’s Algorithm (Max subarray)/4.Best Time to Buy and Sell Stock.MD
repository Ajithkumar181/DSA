Here's your **revision notes**, **dry run**, and **C++ code** for **Leetcode 121: Best Time to Buy and Sell Stock** üîÅüí∞

---

## ‚úÖ **Problem Summary**

You're given an array `prices[]` where `prices[i]` represents the price of a stock on the `i-th` day.

### **Goal:**

Buy **once** and sell **once later** to **maximize profit**.
Return the **maximum profit**, or `0` if no profit is possible.

---

## ‚úÖ **Key Concepts**

* You **must buy before you sell**.
* Track the **minimum price seen so far** (`minPrice`).
* At each step, calculate potential profit:
  `profit = current_price - minPrice`
* Track the **maximum profit** over all days.

---

## ‚úÖ **Dry Run (Example 1)**

```
Input: prices = [7, 1, 5, 3, 6, 4]
minPrice = ‚àû
maxProfit = 0

Day 0: price = 7
  minPrice = min(‚àû, 7) = 7
  profit = 7 - 7 = 0 ‚Üí maxProfit = 0

Day 1: price = 1
  minPrice = min(7, 1) = 1
  profit = 1 - 1 = 0 ‚Üí maxProfit = 0

Day 2: price = 5
  minPrice = 1
  profit = 5 - 1 = 4 ‚Üí maxProfit = 4

Day 3: price = 3
  minPrice = 1
  profit = 3 - 1 = 2 ‚Üí maxProfit = 4

Day 4: price = 6
  minPrice = 1
  profit = 6 - 1 = 5 ‚Üí maxProfit = 5 ‚úÖ

Day 5: price = 4
  minPrice = 1
  profit = 4 - 1 = 3 ‚Üí maxProfit = 5

‚û°Ô∏è Final Answer = **5**
```

---

## ‚úÖ **C++ Code**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;  // Track minimum price so far
        int maxProfit = 0;       // Track maximum profit

        for (int price : prices) {
            if (price < minPrice) {
                minPrice = price;  // Update min price
            } else {
                maxProfit = max(maxProfit, price - minPrice); // Update max profit
            }
        }

        return maxProfit;
    }
};
```

---

## ‚úÖ **Time & Space Complexity**

* **Time:** O(n) ‚Üí Single pass
* **Space:** O(1) ‚Üí Constant space

---

## ‚úÖ **Test Case 2 Dry Run**

```
Input: [7,6,4,3,1]
minPrice = ‚àû, maxProfit = 0

All prices keep decreasing ‚Üí never find a selling day after buying that gives profit.

‚û°Ô∏è Output = 0
```

---

## üîÅ **Common Pattern**

* **Prefix Min + Difference Tracking** ‚Äî good for problems where you need to keep track of the best/worst seen so far.

---

Let me know if you want this in **Python**, **Java**, or **with comments added line-by-line**.
