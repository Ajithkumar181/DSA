Hereâ€™s your **revision notes** with clear explanation and **dry run** for the problem **"Maximum Sum Circular Subarray"** (Leetcode 918), using the code youâ€™ve provided.

---

## âœ… Problem Statement

Given a circular integer array `nums` (i.e., the end connects to the beginning), find the **maximum possible sum of a non-empty subarray** of `nums`.

* A **subarray** may **wrap around** (i.e., starts from the end and continues from the beginning).
* Return the **maximum subarray sum** possible.

---

## âœ… Key Concept

There are **two possible cases**:

1. **Non-circular subarray:** Use **Kadane's algorithm** to find the max subarray.
2. **Circular subarray:** Subtract the **minimum subarray sum** from the total sum.

> Formula:
> **Maximum circular subarray sum = max(Kadane result, total sum - minimum subarray sum)**
> But if all elements are negative, `total - minSum` becomes 0 â†’ handle with special case.

---

## âœ… Code Breakdown

```cpp
int maxSubarraySumCircular(vector<int>& nums) {
    // Case 1: Kadaneâ€™s for max subarray (non-circular)
    int maxCur = nums[0], maxEnd = nums[0];
    for(int i = 1; i < nums.size(); i++) {
        maxCur = max(nums[i], maxCur + nums[i]);
        maxEnd = max(maxEnd, maxCur);
    }

    // Case 2: Kadaneâ€™s for min subarray (used to compute circular max)
    int minCur = nums[0], minEnd = nums[0];
    int total = nums[0];
    for(int i = 1; i < nums.size(); i++) {
        minCur = min(nums[i], minCur + nums[i]);
        minEnd = min(minEnd, minCur);
        total += nums[i];
    }

    // Edge case: All numbers are negative
    if(total - minEnd == 0) return maxEnd;

    return max(maxEnd, total - minEnd);
}
```

---

## âœ… Dry Run

### Input:

```cpp
nums = [5, -3, 5]
```

### Step-by-step:

#### âœ… Step 1: Kadaneâ€™s Max Subarray (Non-circular)

| i | nums\[i] | maxCur = max(nums\[i], maxCur + nums\[i]) | maxEnd |
| - | -------- | ----------------------------------------- | ------ |
| 0 | 5        | maxCur = 5                                | 5      |
| 1 | -3       | maxCur = max(-3, 5 - 3) = 2               | 5      |
| 2 | 5        | maxCur = max(5, 2 + 5) = 7                | 7      |

â†’ `maxEnd = 7` (non-circular max sum)

#### âœ… Step 2: Kadaneâ€™s Min Subarray (for circular case)

| i | nums\[i] | minCur = min(nums\[i], minCur + nums\[i]) | minEnd | total |
| - | -------- | ----------------------------------------- | ------ | ----- |
| 0 | 5        | minCur = 5                                | 5      | 5     |
| 1 | -3       | minCur = min(-3, 5 - 3) = -3              | -3     | 2     |
| 2 | 5        | minCur = min(5, -3 + 5) = 2               | -3     | 7     |

â†’ `total = 7`, `minEnd = -3`

#### âœ… Step 3: Check edge case

* `total - minEnd = 7 - (-3) = 10`
* `maxEnd = 7`

### âœ… Final Output:

```cpp
return max(7, 10) = 10
```

ðŸŸ© Correct! The max sum is from the circular subarray `[5, ..., 5]` (wraps around the -3).

---

## âœ… Edge Case

### Input: `nums = [-2, -3, -1]`

* All elements are negative.

â†’ `maxEnd = -1`
â†’ `total = -6`, `minEnd = -6`, so `total - minEnd = 0` â†’ **Invalid**

Hence, return `maxEnd = -1`

---

## âœ… Time & Space Complexity

* **Time:** O(n) â€“ Single pass for max, min, and total sum.
* **Space:** O(1) â€“ No extra space used.

---

Let me know if youâ€™d like a version that **returns the actual subarray** as well.
