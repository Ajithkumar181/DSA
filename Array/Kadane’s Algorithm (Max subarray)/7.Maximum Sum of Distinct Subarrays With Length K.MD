Here are **revision notes** with a clear explanation and **dry run** for the given problem and your code.

---

## ‚úÖ **Problem Statement Summary**

**Goal:**
Given an array `nums` and integer `k`, find the **maximum sum of a subarray of length `k`** such that **all elements in that subarray are distinct**.

---

## ‚úÖ **Approach: Sliding Window with Hash Map**

### Core Idea:

* Use a **sliding window** of size up to `k`.
* Maintain a **hashmap** `mp` to track element frequencies in the current window.
* Use a variable `cur` to track the **current window sum**.
* Only consider subarrays of size `k` with **all unique elements** (`mp[x] == 1` for all x).
* Update `ans` with the max of `cur`.

---

## ‚úÖ **Variables in Code**

| Variable    | Purpose                                                       |
| ----------- | ------------------------------------------------------------- |
| `i` and `j` | Window pointers (`i`: start, `j`: end)                        |
| `cur`       | Sum of current window                                         |
| `mp`        | Frequency map to ensure all elements in the window are unique |
| `ans`       | Stores the max sum of a valid window of size `k`              |

---

## ‚úÖ **Step-by-Step Dry Run**

### Input: `nums = [1, 2, 1, 3, 4], k = 3`

Initialize:

* `i = 0`, `ans = 0`, `cur = 0`, `mp = {}`

---

### j = 0

* Add `1`: `cur = 1`, `mp = {1: 1}`
* Window size = 1 ‚Üí Not enough yet

---

### j = 1

* Add `2`: `cur = 3`, `mp = {1: 1, 2: 1}`
* Window size = 2 ‚Üí Not enough yet

---

### j = 2

* Add `1`: `cur = 4`, `mp = {1: 2, 2: 1}` ‚ùå Duplicate `1`

#### Shrink window from left:

* Remove `1` (nums\[i]), `cur = 3`, `mp = {1: 1, 2: 1}`, `i = 1`
* Now window: `[2,1]`, size = 2 ‚Üí Still < k

---

### j = 3

* Add `3`: `cur = 6`, `mp = {1: 1, 2: 1, 3: 1}`
* Window size = 3 ‚úîÔ∏è

  * All elements unique ‚Üí `ans = max(0, 6) = 6`
  * Shrink: remove `2`, `cur = 4`, `mp = {1: 1, 2: 0, 3: 1}`, `i = 2`

---

### j = 4

* Add `4`: `cur = 8`, `mp = {1: 1, 3: 1, 4: 1}`
* Window size = 3 ‚úîÔ∏è

  * All elements unique ‚Üí `ans = max(6, 8) = 8`
  * Shrink: remove `1`, `cur = 7`, `i = 3`

---

### Final answer: `8`

---

## ‚úÖ **Final Code Explanation**

```cpp
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        long long ans = 0;
        unordered_map<long long, int> mp;
        long long cur = 0;
        int i = 0;
        
        for (int j = 0; j < nums.size(); j++) {
            cur += nums[j];
            mp[nums[j]]++;

            // Ensure elements in the window are unique
            while (mp[nums[j]] > 1) {
                mp[nums[i]]--;
                cur -= nums[i];
                i++;
            }

            // If window has exactly k elements
            if (j - i + 1 == k) {
                ans = max(ans, cur);
                mp[nums[i]]--;
                cur -= nums[i];
                i++;
            }
        }

        return ans;
    }
};
```

---

## üß† Time and Space Complexity

* **Time:** `O(n)`

  * Each element enters and exits the window at most once.
* **Space:** `O(k)`

  * Map stores at most `k` unique elements.

---

Let me know if you want this logic in Python or in handwritten notes format.
