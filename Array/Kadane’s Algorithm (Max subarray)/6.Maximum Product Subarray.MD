Here's a **complete revision note** with a **step-by-step dry run** for the `maxProduct` function.

---

## ✅ Problem Statement (Maximum Product Subarray)

Given an integer array `nums`, find the **contiguous subarray** (containing at least one number) which has the **largest product**, and return the product.

---

## ✅ Intuition Behind the Code

Multiplying negatives can turn into positives, so we must consider both the **prefix (left to right)** and **suffix (right to left)** products. Why?

* A negative number might become positive if it pairs with another negative later.
* Hence, we keep track of both directions to catch the maximum product subarray.

---

## ✅ Key Variables

```cpp
int prefix = 1;     // Product from left to right
int suffix = 1;     // Product from right to left
int maxi = INT_MIN; // Holds the maximum product found
```

---

## ✅ Algorithm Explanation

1. Traverse the array from both directions simultaneously:

   * Multiply the running product from the front (`prefix`) and from the back (`suffix`).
   * If any product becomes `0`, reset it to `1` (since multiplying by 0 ruins the subarray).
   * Update `maxi` with the maximum of the current prefix, suffix, and previous `maxi`.

2. Return the maximum found.

---

## ✅ Code

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int prefix = 1, suffix = 1;
        int maxi = INT_MIN;
        for (int i = 0; i < n; i++) {
            if (prefix == 0) prefix = 1;
            if (suffix == 0) suffix = 1;

            prefix *= nums[i];
            suffix *= nums[n - 1 - i];

            maxi = max({maxi, prefix, suffix});
        }
        return maxi;
    }
};
```

---

## ✅ Dry Run

Let’s dry run for:

```cpp
nums = [2, 3, -2, 4]
```

| i | nums\[i] | nums\[n-1-i] | prefix    | suffix    | maxi |
| - | -------- | ------------ | --------- | --------- | ---- |
| 0 | 2        | 4            | 1×2=2     | 1×4=4     | 4    |
| 1 | 3        | -2           | 2×3=6     | 4×-2=-8   | 6    |
| 2 | -2       | 3            | 6×-2=-12  | -8×3=-24  | 6    |
| 3 | 4        | 2            | -12×4=-48 | -24×2=-48 | 6    |

🔁 `prefix` and `suffix` are reset to 1 when they become 0 (not in this case).

✅ Final answer = `6`, which is product of subarray `[2,3]`

---

## ✅ Edge Case Dry Run

```cpp
nums = [-2, 0, -1]
```

| i | nums\[i] | nums\[n-1-i] | prefix  | suffix  | maxi |
| - | -------- | ------------ | ------- | ------- | ---- |
| 0 | -2       | -1           | -2      | -1      | -1   |
| 1 | 0        | 0            | 0 ⇒ 1   | 0 ⇒ 1   | -1   |
| 2 | -1       | -2           | 1×-1=-1 | 1×-2=-2 | -1   |

✅ Final answer = `0` from subarray `[0]`

---

## ✅ Time & Space Complexity

* **Time Complexity**: O(n) — single pass through the array
* **Space Complexity**: O(1) — only variables used, no extra space

---

## ✅ When to Use This Approach

* Use this optimized approach when **you want to avoid nested loops** (brute force is O(n²)).
* Works great even with **zeros and negative numbers**.

---

Let me know if you'd like this written as notes in a PDF or if you want brute-force comparison too.
