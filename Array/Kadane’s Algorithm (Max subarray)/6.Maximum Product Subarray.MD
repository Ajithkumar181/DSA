Here's a **complete revision note** with a **step-by-step dry run** for the `maxProduct` function.

---

## âœ… Problem Statement (Maximum Product Subarray)

Given an integer array `nums`, find the **contiguous subarray** (containing at least one number) which has the **largest product**, and return the product.

---

## âœ… Intuition Behind the Code

Multiplying negatives can turn into positives, so we must consider both the **prefix (left to right)** and **suffix (right to left)** products. Why?

* A negative number might become positive if it pairs with another negative later.
* Hence, we keep track of both directions to catch the maximum product subarray.

---

## âœ… Key Variables

```cpp
int prefix = 1;     // Product from left to right
int suffix = 1;     // Product from right to left
int maxi = INT_MIN; // Holds the maximum product found
```

---

## âœ… Algorithm Explanation

1. Traverse the array from both directions simultaneously:

   * Multiply the running product from the front (`prefix`) and from the back (`suffix`).
   * If any product becomes `0`, reset it to `1` (since multiplying by 0 ruins the subarray).
   * Update `maxi` with the maximum of the current prefix, suffix, and previous `maxi`.

2. Return the maximum found.

---

## âœ… Code

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int prefix = 1, suffix = 1;
        int maxi = INT_MIN;
        for (int i = 0; i < n; i++) {
            if (prefix == 0) prefix = 1;
            if (suffix == 0) suffix = 1;

            prefix *= nums[i];
            suffix *= nums[n - 1 - i];

            maxi = max({maxi, prefix, suffix});
        }
        return maxi;
    }
};
```

---

## âœ… Dry Run

Letâ€™s dry run for:

```cpp
nums = [2, 3, -2, 4]
```

| i | nums\[i] | nums\[n-1-i] | prefix    | suffix    | maxi |
| - | -------- | ------------ | --------- | --------- | ---- |
| 0 | 2        | 4            | 1Ã—2=2     | 1Ã—4=4     | 4    |
| 1 | 3        | -2           | 2Ã—3=6     | 4Ã—-2=-8   | 6    |
| 2 | -2       | 3            | 6Ã—-2=-12  | -8Ã—3=-24  | 6    |
| 3 | 4        | 2            | -12Ã—4=-48 | -24Ã—2=-48 | 6    |

ðŸ” `prefix` and `suffix` are reset to 1 when they become 0 (not in this case).

âœ… Final answer = `6`, which is product of subarray `[2,3]`

---

## âœ… Edge Case Dry Run

```cpp
nums = [-2, 0, -1]
```

| i | nums\[i] | nums\[n-1-i] | prefix  | suffix  | maxi |
| - | -------- | ------------ | ------- | ------- | ---- |
| 0 | -2       | -1           | -2      | -1      | -1   |
| 1 | 0        | 0            | 0 â‡’ 1   | 0 â‡’ 1   | -1   |
| 2 | -1       | -2           | 1Ã—-1=-1 | 1Ã—-2=-2 | -1   |

âœ… Final answer = `0` from subarray `[0]`

---

## âœ… Time & Space Complexity

* **Time Complexity**: O(n) â€” single pass through the array
* **Space Complexity**: O(1) â€” only variables used, no extra space

---

## âœ… When to Use This Approach

* Use this optimized approach when **you want to avoid nested loops** (brute force is O(nÂ²)).
* Works great even with **zeros and negative numbers**.

---

Let me know if you'd like this written as notes in a PDF or if you want brute-force comparison too.
